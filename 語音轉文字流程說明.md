# 語音轉文字流程說明

## 🔍 您的問題

您問到：「語音轉文字我現在不是用 Gemini 嗎？」

## ✅ 正確答案

**不是的！** 語音轉文字使用的是 **AssemblyAI**，不是 Gemini。

但您的混淆是可以理解的，因為系統有兩種處理模式：

---

## 📊 兩種處理模式

### 模式 1：快速模式（優先使用）⚡

**使用 Gemini 直接分析 YouTube URL**

```
YouTube URL 
  ↓
Gemini 直接「看」影片內容（不是語音轉文字）
  ↓
直接生成摘要和腳本
```

**特點：**
- ✅ 速度快（跳過下載和轉錄）
- ✅ 不需要 AssemblyAI
- ❌ **不是真正的語音轉文字**
- ❌ Gemini 是直接分析影片內容，不是轉錄音訊
- ❌ 可能不夠準確（依賴 Gemini 對影片的理解）

**代碼位置：**
- `server/youtubeService.ts` → `analyzeYoutubeUrlDirectly()`
- 使用 `GOOGLE_GEMINI_API_KEY`

---

### 模式 2：傳統模式（回退方案）🎯

**真正的語音轉文字流程**

```
YouTube URL
  ↓
下載音訊檔案
  ↓
AssemblyAI 語音轉文字 ⭐（真正的轉錄）
  ↓
Gemini 分析轉錄文字
  ↓
生成摘要和腳本
```

**特點：**
- ✅ **真正的語音轉文字**（使用 AssemblyAI）
- ✅ 準確度高（基於實際音訊轉錄）
- ✅ 有完整的逐字稿
- ❌ 速度較慢（需要下載和轉錄）

**代碼位置：**
- `server/youtubeService.ts` → `transcribeYoutubeVideo()`
- `server/_core/voiceTranscription.ts` → `transcribeAudio()`
- 使用 `ASSEMBLYAI_API_KEY`（語音轉文字）
- 使用 `GOOGLE_GEMINI_API_KEY`（內容分析）

---

## 🔄 實際運作流程

根據 `server/youtubeService.ts` 的 `processYoutubeToPodcast()` 函數：

```typescript
// 1. 優先嘗試：Gemini 直接分析（快速模式）
try {
  const directResult = await analyzeYoutubeUrlDirectly(youtubeUrl);
  // 如果成功，直接返回（跳過轉錄）
  return directResult;
} catch (error) {
  // 2. 如果失敗，回退到傳統方式
}

// 3. 傳統方式：下載 + AssemblyAI 轉錄 + Gemini 分析
const transcriptionResult = await transcribeYoutubeVideo(youtubeUrl);
// ↑ 這裡使用 AssemblyAI 進行真正的語音轉文字
```

---

## 📝 總結

| 服務 | 用途 | 是否為語音轉文字 |
|------|------|-----------------|
| **AssemblyAI** | 真正的語音轉文字 | ✅ **是** |
| **Gemini（快速模式）** | 直接分析影片內容 | ❌ **不是**（是內容分析） |
| **Gemini（傳統模式）** | 分析轉錄後的文字 | ❌ **不是**（是內容分析） |

---

## 🎯 關鍵點

1. **語音轉文字 = AssemblyAI**（在傳統模式中使用）
2. **Gemini 快速模式**：不是語音轉文字，而是讓 AI 直接「看」影片
3. **Gemini 傳統模式**：分析已經轉錄好的文字，不是轉錄本身

---

## 💡 建議

如果您想要：
- **真正的語音轉文字**：必須保留 AssemblyAI
- **快速但不準確**：可以只用 Gemini 快速模式（但這不是語音轉文字）
- **準確且完整**：使用傳統模式（AssemblyAI + Gemini）

**目前系統的設計**：
- 優先使用 Gemini 快速模式（如果成功）
- 如果失敗，自動回退到 AssemblyAI 轉錄（確保準確性）

所以 **AssemblyAI 仍然是必要的**，作為回退方案和確保準確性的保障。

